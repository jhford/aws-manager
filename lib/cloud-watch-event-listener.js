const aws = require('aws-sdk');
const sqslib = require('sqs-simple');
const events = require('events');
const assert = require('assert');
const {runAWSRequest} = require('./aws-request');
const log = require('./log');

class CloudWatchEventListener extends events.EventEmitter {

  constructor({
    state,
    sqs,
    ec2,
    queueName = 'ec2-events',
    monitor,
    region,
    runaws = runAWSRequest,
  }) {
    super();
    
    // Store the reference to the State we're using
    assert(typeof state === 'object');
    this.state = state;

    // Store the list of regions in which we're operating
    assert(typeof region === 'string');
    this.region = region;

    // Store some basic configuration values
    assert(typeof queueName === 'string');
    this.queueName = queueName;

    // Set up all the AWS clients that we'll possibly need
    assert(sqs);
    this.sqs = sqs;

    assert(ec2);
    this.ec2 = ec2;

    // We should always be using a
    assert(this.ec2.config.region === region);
    assert(this.sqs.config.region === region);

    // Store the reference to the monitor instance
    this.monitor = monitor.prefix('cloud-watch-events');

    this.queueUrl = undefined;

    this.sqsQueue = undefined;

    this.runaws = runaws;
  }

  async init() {
    this.queueUrl = await sqslib.getQueueUrl({sqs: this.sqs, queueName: this.queueName});

    this.sqsQueue = new sqslib.QueueListener({
      sqs: this.sqs,
      queueUrl: this.queueUrl,
      decodeMessage: false,
      maxNumberOfMessages: 10,
      sequential: true,
      handler: async msg => {
        let doodad = this.monitor.timeKeeper('message-handler-time');
        await this.__handler(msg);
        doodad.measure();
        this.monitor.count('handled-messages', 1);
      },
    });

    this.sqsQueue.on('error', (err, errType) => {
      // We probably want to bubble this up... maybe?
      //this.emit('error', err, errType);
      this.monitor.count('handler-errors', 1);
      log.error({err, errType}, 'SQS Handler Error');
      this.monitor.reportError(err, {errType});
    });
  }

  async __handler(msg) {
    let body = JSON.parse(msg);
    let region = body.region;
    let id = body.detail['instance-id'];
    let state = body.detail.state;
    // Not a great name, but this variable is the time that the CloudWatch
    // Event message was generated by the API, not the time at which we
    // received it
    let generated = new Date(body.time);

    let hlog = log.child({region, id, state});

    // Let's log this event.  We're doing this outside of any transaction because we need to
    // log it regardless of the outcome
    try {
      await this.state.logCloudWatchEvent({region, id, state, generated});
    } catch (err) {
      // We don't want to block things, but let's bubble up the error for the
      // time being
      this.monitor.reportError(err);
      hlog.warn(err, 'failure while reporting cloudwatch event to database');
    }

    if (state === 'terminated') {
      let transaction = await this.state.beginTransaction();
      let instances = await this.state.listInstances({region, id}, transaction);
      if (instances.length === 0) {
        hlog.debug('untracked instance termination');
        await this.state.commitTransaction(transaction);
        return;
      }
      let instance = instances[0];

      await this.state.upsertTermination({
        id: instance.id,
        workerType: instance.workerType,
        region: instance.region,
        az: instance.az,
        instanceType: instance.instanceType,
        imageId: instance.imageId,
        launched: instance.launched,
        terminated: generated,
        lastEvent: generated,
      }, transaction);
      await this.state.removeInstance({region, id}, transaction);
      await this.state.commitTransaction(transaction);
      hlog.debug({
        workerType: instance.workerType,
        az: instance.az,
      }, 'tracked instance termination');

      // We want to track how long an instance lived for
      let lifespan = generated - instance.launched;
      let groupings = [
        'overall',
        `instance-type.${instance.instanceType}`,
        `worker-type.${instance.workerType}`,
        `region.${instance.region}`,
      ].map(x => 'instance-lifespan.' + x);
      for (let grouping of groupings) {
        this.monitor.measure(grouping, lifespan);
      }
    } else {
      let wasUpdated = await this.state.updateInstanceState({
        region,
        id,
        state,
        lastEvent: generated,
      });
      if (wasUpdated) {
        hlog.info('new state for instance set');
      } else {
        hlog.debug('no update to instance state');
      };
    }
  }

  start() {
    assert(this.sqsQueue);
    this.sqsQueue.start();
  }
  
  stop() {
    assert(this.sqsQueue);
    this.sqsQueue.stop();
  }
}

class DeadCloudWatchEventListener extends events.EventEmitter {

  constructor({
    sqs,
    queueName = 'ec2-events',
    monitor,
    region,
  }) {
    super();

    // Store the list of regions in which we're operating
    assert(typeof region === 'string');
    this.region = region;

    // Store some basic configuration values
    assert(typeof queueName === 'string');
    this.queueName = queueName;

    // Set up all the AWS clients that we'll possibly need
    assert(sqs);
    this.sqs = sqs;

    assert(this.sqs.config.region === region);

    // Store the reference to the monitor instance
    this.monitor = monitor.prefix('cloud-watch-events');

    this.queueUrl = undefined;

    this.sqsQueue = undefined;
  }

  async init() {
    this.queueUrl = await sqslib.getQueueUrl({sqs: this.sqs, queueName: this.queueName});

    this.sqsQueue = new sqslib.QueueListener({
      sqs: this.sqs,
      queueUrl: this.queueUrl,
      decodeMessage: false,
      maxNumberOfMessages: 10,
      maxReceiveCount: 20,
      handler: async msg => {
        await this.__handler(msg);
      },
    });

    this.sqsQueue.on('error', (err, errType) => {
      // We probably want to bubble this up... maybe?
      //this.emit('error', err, errType);
      log.error({err, errType}, 'SQS Handler Error');
    });
  }

  async __handler(msg) {
    let errorMsg = [
      'A CloudWatch Event message has failed too many times.  ',
      'Failing message follows:\n\n',
      JSON.stringify(msg),
    ].join('');
    this.monitor.reportError(new Error(errorMsg), 'info');
  }

  start() {
    assert(this.sqsQueue);
    this.sqsQueue.start();
  }
  
  stop() {
    assert(this.sqsQueue);
    this.sqsQueue.stop();
  }
}

async function initCloudWatchEventListener(opts) {
  let obj = new CloudWatchEventListener(opts);
  await obj.init();
  return obj;
}

async function initDeadCloudWatchEventListener(opts) {
  let obj = new DeadCloudWatchEventListener(opts);
  await obj.init();
  return obj;
}

module.exports = {
  initCloudWatchEventListener,
  initDeadCloudWatchEventListener,
  CloudWatchEventListener,
};
