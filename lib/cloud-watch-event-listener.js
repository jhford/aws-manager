const aws = require('aws-sdk');
const sqslib = require('sqs-simple');
const _ = require('lodash');
const events = require('events');
const assert = require('assert');
const {runAWSRequest} = require('./aws-request');
const log = require('./log');

class CloudWatchEventListener extends events.EventEmitter {

  constructor({
    state,
    sqs,
    ec2,
    queueName = 'ec2-events',
    monitor,
    region,
    runaws = runAWSRequest,
  }) {
    super();
    
    // Store the reference to the State we're using
    assert(typeof state === 'object');
    this.state = state;

    // Store the list of regions in which we're operating
    assert(typeof region === 'string');
    this.region = region;

    // Store some basic configuration values
    assert(typeof queueName === 'string');
    this.queueName = queueName;

    // Set up all the AWS clients that we'll possibly need
    assert(sqs);
    this.sqs = sqs;

    assert(ec2);
    this.ec2 = ec2;

    // We should always be using a
    assert(this.ec2.config.region === region);
    assert(this.sqs.config.region === region);

    // Store the reference to the monitor instance
    this.monitor = monitor.prefix('cloud-watch-events');

    this.queueUrl = undefined;

    this.sqsQueue = undefined;

    this.runaws = runaws;
  }

  async init() {
    this.queueUrl = await sqslib.getQueueUrl({sqs: this.sqs, queueName: this.queueName});

    this.sqsQueue = new sqslib.QueueListener({
      sqs: this.sqs,
      queueUrl: this.queueUrl,
      decodeMessage: false,
      maxNumberOfMessages: 10,
      sequential: true,
      handler: async msg => {
        let doodad = this.monitor.timeKeeper('message-handler-time');
        await this.__handler(msg);
        doodad.measure();
        this.monitor.count('handled-messages', 1);
      },
    });

    this.sqsQueue.on('error', (err, errType) => {
      // We probably want to bubble this up... maybe?
      //this.emit('error', err, errType);
      this.monitor.count('handler-errors', 1);
      log.error({err, errType}, 'SQS Handler Error');
      this.monitor.reportError(err, {errType});
    });
  }

  async __handler(msg) {
    let body = JSON.parse(msg);
    let region = body.region;
    let id = body.detail['instance-id'];
    let state = body.detail.state;
    // Not a great name, but this variable is the time that the CloudWatch
    // Event message was generated by the API, not the time at which we
    // received it
    let generated = new Date(body.time);

    let transaction = await this.state.beginTransaction();

    let dbResponse;

    dbResponse = await this.state.listInstances({region, id}, transaction);

    if (dbResponse.length > 1) {
      // for this case to be hit, there'd have to be a database schema problem
      await this.state.commitTransaction(transaction);
      throw new Error('verify database integrity!');
    } else if (dbResponse.length < 1) {
      await this.state.commitTransaction(transaction);
      log.debug({id, region, state}, 'skipping messages for untracked instances');
    } else {
      // Now that we're only monitoring instances which are in the state
      // database, we no longer want to log cloudwatch events for unrelated
      // instances.  We do not do this as part of the ongoing transaction
      // because we want this logged regardless of whether that transaction
      // results in a commit or rollback
      try {
        await this.state.logCloudWatchEvent({region, id, state, generated});
      } catch (err) {
        // We don't want to block things, but let's bubble up the error for the
        // time being
        this.monitor.reportError(err);
      }
      
      dbResponse = dbResponse[0];
      // If there's a response from the database, we know that we already have
      // this information in the database.  We'll use this information to
      // figure out the immutable metadata

      let logInfo = {
        workerType: dbResponse.workerType,
        region: dbResponse.region,
        az: dbResponse.az,
        id: id,
        instanceType: dbResponse.instanceType,
        imageId: dbResponse.imageId,
        launched: dbResponse.launched,
        state,
        lastEvent: generated,
        metadataSource: 'db',
      };
      
      // Note that since we're now inserting instances directly into the
      // database now, we're always going to have a pending state in the db for
      // managed instances.  This means that most 'pending' state messages will
      // be ignored.
      if (dbResponse.lastEvent && dbResponse.lastEvent === generated) {
        log.warn('whoa!');
      } 

      if (dbResponse.lastEvent && dbResponse.lastEvent < generated) {
        // We only want to handle the terminated case specially, since in
        // other cases we'll filter for only pending and running as query
        // options when talking to the db
        if (state === 'terminated') {
          await this.state.upsertTermination({
            id: dbResponse.id,
            workerType: dbResponse.workerType,
            region: dbResponse.region,
            az: dbResponse.az,
            instanceType: dbResponse.instanceType,
            imageId: dbResponse.imageId,
            launched: dbResponse.launched,
            terminated: generated,
            lastEvent: generated,
          }, transaction);
          await this.state.removeInstance({region, id}, transaction);
          log.debug(logInfo, 'CloudWatch Event resulting in deletion');
        } else {
          await this.state.updateInstanceState({
            region,
            id,
            state,
            lastEvent: generated,
          }, transaction);
          log.info(logInfo, 'CloudWatch Event resulting in state update');
        }
        await this.state.commitTransaction(transaction);
      } else {
        // While we didn't write anything, we did lock the row and claim a
        // client.  We should release those
        await this.state.commitTransaction(transaction);

        this.monitor.count('global.cwe-out-of-order.count', 1);
        this.monitor.count(`${region}.cwe-out-of-order.count`, 1);
        // We want to see how big our gaps in out of order delivery are.
        let delay = dbResponse.lastEvent - generated;
        this.monitor.measure('global.cwe-out-of-order.delay', delay);
        this.monitor.measure(`${region}.cwe-out-of-order.delay`, delay);
        log.info({
          region,
          id,
          state,
          delay,
          lastEvent: dbResponse.lastEvent,
          generated,
          currentDbState: dbResponse.state,
        }, 'CloudWatch Event delivered out of order');
      }
    }
  }

  start() {
    assert(this.sqsQueue);
    this.sqsQueue.start();
  }
  
  stop() {
    assert(this.sqsQueue);
    this.sqsQueue.stop();
  }
}

class DeadCloudWatchEventListener extends events.EventEmitter {

  constructor({
    sqs,
    queueName = 'ec2-events',
    monitor,
    region,
  }) {
    super();

    // Store the list of regions in which we're operating
    assert(typeof region === 'string');
    this.region = region;

    // Store some basic configuration values
    assert(typeof queueName === 'string');
    this.queueName = queueName;

    // Set up all the AWS clients that we'll possibly need
    assert(sqs);
    this.sqs = sqs;

    assert(this.sqs.config.region === region);

    // Store the reference to the monitor instance
    this.monitor = monitor.prefix('cloud-watch-events');

    this.queueUrl = undefined;

    this.sqsQueue = undefined;
  }

  async init() {
    this.queueUrl = await sqslib.getQueueUrl({sqs: this.sqs, queueName: this.queueName});

    this.sqsQueue = new sqslib.QueueListener({
      sqs: this.sqs,
      queueUrl: this.queueUrl,
      decodeMessage: false,
      maxNumberOfMessages: 10,
      maxReceiveCount: 20,
      handler: async msg => {
        await this.__handler(msg);
      },
    });

    this.sqsQueue.on('error', (err, errType) => {
      // We probably want to bubble this up... maybe?
      //this.emit('error', err, errType);
      log.error({err, errType}, 'SQS Handler Error');
    });
  }

  // TODO: Maybe what we should do is store these instance ids in a table and
  // poll them to see when they do become available and insert them into the
  // database *then*
  async __handler(msg) {
    let errorMsg = [
      'UNTRACKED INSTANCE\n\n',
      'A CloudWatch Event message has failed.  This is likely because the',
      'EC2 API call to DescribeInstances did not return information.  While',
      'we do retry this a number of times, we eventually give up.  This instance',
      'should probably be killed or else deleted.',
    ].join(' ');

    errorMsg += '\nFailing message follows:\n\n';
    errorMsg += msg;

    this.monitor.reportError(new Error(errorMsg), 'info');
  }

  start() {
    assert(this.sqsQueue);
    this.sqsQueue.start();
  }
  
  stop() {
    assert(this.sqsQueue);
    this.sqsQueue.stop();
  }
}

async function initCloudWatchEventListener(opts) {
  let obj = new CloudWatchEventListener(opts);
  await obj.init();
  return obj;
}

async function initDeadCloudWatchEventListener(opts) {
  let obj = new DeadCloudWatchEventListener(opts);
  await obj.init();
  return obj;
}

module.exports = {
  initCloudWatchEventListener,
  initDeadCloudWatchEventListener,
  CloudWatchEventListener,
};
